#version 450

#define M_PI 3.1415926535897932384626433832795

layout (local_size_x = 16, local_size_y = 16) in;

struct complex {
	float real;
	float im;
};

complex mul(complex c0, complex c1) {
	complex c;
	c.real = c0.real * c1.real - c0.im * c1.im;
	c.im = c0.real * c1.im + c0.im * c1.real;
	return c;
}

complex add(complex c0, complex c1) {
	complex c;
	c.real = c0.real + c1.real;
	c.im = c0.im + c1.im;
	return c;
}

complex conj(complex c) {
	return complex(c.real, -c.im);
}

void main() {
	vec2 x = ivec2(gl_GlobalInvocationID.xy) - float(constants.N) / 2;

	vec2 k = vec2(2 * M_PI * x.x/constants.L, 2 * M_PI * x.y/constants.L);

	float magnitude = length(k);
	if (magnitude < 0.00001) {
		magnitude = 0.00001;
	}

	float w = sqrt(9.81 * magnitude);

	complex fourier_amp = complex(imageLoad(tilde_h0k, ivec2(gl_GlobalInvocationID.xy)).r,
								  imageLoad(tilde_h0k, ivec2(gl_GlobalInvocationID.xy)).g);

	complex fourier_amp_conj = conj(complex(imageLoad(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy)).r,
										    imageLoad(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy)).g));

	float cosinus = cos(w * constants.t);
	float sinus = sin(w * constants.t);

	// euler formula
	complex exp_iwt = complex(cosinus, sinus);
	complex exp_iwt_inv = complex(cosinus, -sinus);

	// dy
	complex h_k_t_dy = add(mul(fourier_amp, exp_iwt), (mul(fourier_amp_conj, exp_iwt_inv)));

	// dx
	complex dx = complex(0, -k.x / magnitude);
	complex h_k_t_dx = mul(dx, h_k_t_dy);

	// dz
	complex dy = complex(0, -k.y / magnitude);
	complex h_k_t_dz = mul(dy, h_k_t_dy);

	imageStore(tilde_hkt_dy, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dy.real, h_k_t_dy.im, 0, 1));
	imageStore(tilde_hkt_dx, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dx.real, h_k_t_dx.im, 0, 1));
	imageStore(tilde_hkt_dz, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dz.real, h_k_t_dz.im, 0, 1));
}
